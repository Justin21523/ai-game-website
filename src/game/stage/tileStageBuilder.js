// Tile stage builder (Phaser Tilemap + collision helpers).
//
// Responsibilities:
// - Take a `stageDefinition` (generated by `tileStageGenerator.js`)
// - Ensure the tileset atlas exists (see `tilesetAtlas.js`)
// - Create a Phaser Tilemap + TilemapLayer for rendering
// - Configure collision tiles
// - Extract "platform top surfaces" to feed into the AI platform graph
//
// This module intentionally does NOT create fighters or AI.
// It only builds the stage (rendering + collision data).

import { ensureTilesetAtlas, getTilesetCollisionSets, TILESET_ATLAS_KEY } from './tilesetAtlas.js'
import { createDebugLogger } from '../debug/debugLogger.js'

const log = createDebugLogger('TileStageBuilder')

// Build a tile stage inside the given scene.
export function buildTileStage(scene, { stageDefinition }) {
  if (log.enabled && log.verbose) {
    log.groupCollapsed('build:start', {
      style: stageDefinition?.meta?.style,
      seed: stageDefinition?.meta?.seed,
      widthTiles: stageDefinition?.widthTiles,
      heightTiles: stageDefinition?.heightTiles,
      offsetX: stageDefinition?.offsetX,
      offsetY: stageDefinition?.offsetY,
      tileSizePx: stageDefinition?.tileSizePx,
    })
    log.groupEnd()
  }

  // Ensure the atlas exists (it is created once and reused).
  const atlasInfo = ensureTilesetAtlas(scene, {
    tileSizePx: stageDefinition.tileSizePx,
  })

  // Collision tiles are derived from `/assets/tileset.json`.
  const collision = getTilesetCollisionSets()
  const collidableSet = new Set([...collision.solid, ...collision.oneWay])
  const oneWaySet = new Set(collision.oneWay)

  if (log.enabled && log.verbose) {
    log.info('collision-sets', {
      solidCount: collision.solid.length,
      oneWayCount: collision.oneWay.length,
      collidableCount: collidableSet.size,
      atlasKey: atlasInfo.atlasKey,
      atlasTileSizePx: atlasInfo.tileSizePx,
      atlasColumns: atlasInfo.columns,
      atlasRows: atlasInfo.rows,
    })
  }

  // We build multiple visual layers to match the tileset's intended usage:
  // - background tiles (non-colliding)
  // - terrain tiles (colliding)
  // - foreground tiles (non-colliding)
  //
  // NOTE:
  // For simplicity we create *separate* Tilemaps for each layer.
  // This avoids needing a complex "multi-layer map" definition at this stage.
  const maps = []
  const layers = {
    background: null,
    terrain: null,
    foreground: null,
  }

  const backgroundBuilt = createLayerFromGrid(scene, {
    grid: stageDefinition.layers.background,
    atlasKey: atlasInfo.atlasKey,
    tileSizePx: stageDefinition.tileSizePx,
    offsetX: stageDefinition.offsetX,
    offsetY: stageDefinition.offsetY,
    depth: -10,
    alpha: 0.85,
  })
  if (backgroundBuilt) {
    maps.push(backgroundBuilt.map)
    layers.background = backgroundBuilt.layer
  }

  const terrainBuilt = createLayerFromGrid(scene, {
    grid: stageDefinition.layers.terrain,
    atlasKey: atlasInfo.atlasKey,
    tileSizePx: stageDefinition.tileSizePx,
    offsetX: stageDefinition.offsetX,
    offsetY: stageDefinition.offsetY,
    depth: 0,
  })
  if (terrainBuilt) {
    maps.push(terrainBuilt.map)
    layers.terrain = terrainBuilt.layer

    // Mark all collidable tile indices as "colliding" in Phaser.
    // One-way behavior will be enforced by a collider processCallback in BattleScene.
    terrainBuilt.layer.setCollision([...collidableSet])
  } else if (log.enabled) {
    log.error('terrain-layer-missing', {
      style: stageDefinition?.meta?.style,
      seed: stageDefinition?.meta?.seed,
    })
  }

  const foregroundBuilt = createLayerFromGrid(scene, {
    grid: stageDefinition.layers.foreground,
    atlasKey: atlasInfo.atlasKey,
    tileSizePx: stageDefinition.tileSizePx,
    offsetX: stageDefinition.offsetX,
    offsetY: stageDefinition.offsetY,
    depth: 12,
  })
  if (foregroundBuilt) {
    maps.push(foregroundBuilt.map)
    layers.foreground = foregroundBuilt.layer
  }

  // Extract platform top surfaces to support the AI platform graph.
  // This is purely geometric and does not depend on physics engine internals.
  const platformObjects = extractPlatformSurfacesFromGrid({
    grid: stageDefinition.layers.terrain,
    tileSizePx: stageDefinition.tileSizePx,
    offsetX: stageDefinition.offsetX,
    offsetY: stageDefinition.offsetY,
    isCollidableTileIndex: (tileIndex) => collidableSet.has(tileIndex),
    isOneWayTileIndex: (tileIndex) => oneWaySet.has(tileIndex),
  })

  return {
    atlas: atlasInfo,
    maps,
    layers,
    collision,
    platformObjects,
    // Bounds in world pixels (useful for camera/world bounds if you expand later).
    bounds: {
      widthPx: stageDefinition.widthTiles * stageDefinition.tileSizePx,
      heightPx: stageDefinition.heightTiles * stageDefinition.tileSizePx,
      offsetX: stageDefinition.offsetX,
      offsetY: stageDefinition.offsetY,
    },
  }
}

function createLayerFromGrid(
  scene,
  { grid, atlasKey, tileSizePx, offsetX, offsetY, depth = 0, alpha = 1 } = {},
) {
  // Create a tilemap layer directly from a 2D grid.
  //
  // Each grid entry is either:
  // - -1: empty
  // -  0..N: tile index into the tileset atlas
  if (!Array.isArray(grid) || !grid.length) return null

  const map = scene.make.tilemap({
    data: grid,
    tileWidth: tileSizePx,
    tileHeight: tileSizePx,
  })

  const tileset = map.addTilesetImage(
    TILESET_ATLAS_KEY,
    atlasKey,
    tileSizePx,
    tileSizePx,
    0,
    0,
  )

  const layer = map.createLayer(0, tileset, offsetX, offsetY)
  layer.setDepth(depth)
  layer.setAlpha(alpha)

  return { map, layer }
}

// Convert a collidable tile grid into a list of "top surface" rectangles.
//
// Why:
// - Physics collision needs *all* solid tiles (walls, blocks, etc.).
// - Platform-fighter AI mainly needs *walkable surfaces* (the top of platforms).
//
// Heuristic:
// - A tile is a "top surface tile" if:
//   - the tile is collidable
//   - AND the tile above it is NOT collidable (or out of bounds)
// - We then merge horizontal runs into one surface rectangle.
function extractPlatformSurfacesFromGrid({
  grid,
  tileSizePx,
  offsetX,
  offsetY,
  isCollidableTileIndex,
  isOneWayTileIndex,
}) {
  const platforms = []

  // Small thickness so the platform node has a "top" that aligns with the tile top.
  const surfaceThicknessPx = Math.max(6, Math.floor(tileSizePx * 0.25))

  const heightTiles = grid.length
  const widthTiles = grid[0]?.length ?? 0

  for (let y = 0; y < heightTiles; y += 1) {
    let runStartX = null
    let runIsOneWay = true

    for (let x = 0; x <= widthTiles; x += 1) {
      // We iterate one extra step (x === widthTiles) to flush any active run.
      const inBounds = x < widthTiles

      const tileIndex = inBounds ? grid[y][x] : -1
      const isCollidableHere = inBounds && tileIndex !== -1 && isCollidableTileIndex(tileIndex)

      // Determine if there is a collidable tile above.
      const aboveIndex = y > 0 && inBounds ? grid[y - 1][x] : -1
      const isCollidableAbove = aboveIndex !== -1 && isCollidableTileIndex(aboveIndex)

      // Top surface tile iff collidableHere and NOT collidableAbove.
      const isSurfaceTile = isCollidableHere && !isCollidableAbove

      if (isSurfaceTile && runStartX == null) {
        // Start a new run.
        runStartX = x
        runIsOneWay = true
      }

      // Track whether the entire run is made of one-way tiles.
      // If any tile in the run is solid, the run is not one-way.
      if (isSurfaceTile) {
        const isOneWay =
          typeof isOneWayTileIndex === 'function' ? isOneWayTileIndex(tileIndex) : false
        runIsOneWay = runIsOneWay && isOneWay
      }

      if ((!isSurfaceTile || !inBounds) && runStartX != null) {
        // End the run at x - 1.
        const runEndX = x - 1
        const runLength = runEndX - runStartX + 1

        // Convert tile coordinates to world pixels.
        const widthPx = runLength * tileSizePx
        const topY = offsetY + y * tileSizePx
        const centerX = offsetX + runStartX * tileSizePx + widthPx / 2
        const centerY = topY + surfaceThicknessPx / 2

        platforms.push({
          x: centerX,
          y: centerY,
          width: widthPx,
          height: surfaceThicknessPx,
          // Mark whether this surface is a one-way platform.
          // This is used by AI so it can choose to drop through when chasing downwards.
          oneWay: runIsOneWay,
        })

        runStartX = null
      }
    }
  }

  return platforms
}
